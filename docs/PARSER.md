## Базовый синтаксис

Все выражения парсера начинаются с символов **{$** и закачниваются **}**. Например **{$out:'Hello'}**
Внутри выражения может быть записана команда со списком аргументов или же имя переменной.
Общий синтаксис для команды выглядит как: **{$команда:агумент1:агрумент2:аргументN}**.
Для вывода перменной: **{$имя_перменной}**
При этом есть команды не принимающие какие либо аргументы.В этом случае её вызов похож на вывод перменной: **{$команда}**

### Команды

Команды можно поделить на 3 основные группы:

1. Одиночные команды: возвращающие значание. Например: **{$calc:1+1}** напечатает 2
2. Блочные команды: условия и циклы. После каждой из эих команд должна выполянся команда *end*. Пример: **{$if:true} Hello {$end}**
3. Вложенные команды. Результат одной команды может быть использован как агрумент для другой. Например **{$out:{$calc:1 + 1}}**

#### Команды для манипуляции с переменными

*var* - создает перменную с заданым именем. Формат команды **{$var:имя_переменной:значение_переменной}**
Например **{$var:hello:'world'}** создает перменную hello с строквым значением world

*arr* - позволят создать переменую массив. Формат команды **{$arr:имя_переменной:елемент0:елмент1:елементN}**

*hashSet* - аналогичено arr, только созатеся HashSet переменных

*hashMap* - позволят создать HashMap переменных. Формат команды **{$hashMap:имя_переменной:имя_ключа:значение_ключа}**
Команду можно использовать несколько раз с одним и тем же именем переменной, для добовляния новых ключей в мапу.

*del* - удаляет переменную. Формат команды **{$del:имя_переменной}**

*set* и область видимости переменных
Есть 2 области видимости переменной: глобальная и внутри блочной команды.
При это если именна переменных совпадают то приотритет имеет переменная которая находится глубже в стеке блочных команды.
Пример:
```
{$var:a:'test1'}
{$if:true}
    {$var:a:'test2'}
    {$a}
{$end}
{$a}
```
Результатом этого шаблона будет: **test2test1** т.к. внутри блока из была создана **новая** переменная 'a' и при выходе из блока она была удалена.
Ингода необходимо задать значения для переменной внутри блока а не создавать локальную переменную. Для этого можно использовать команду *set*.
*set* - создает новую переменную если такой нет в текущей области видимости, или задает её значение. Формат анлогичен *var*

#### Команды приведения типов

*bool* - приведение к логическому значению.
 
* Как false трактуются - пустые строки, 0, null, пустые коллекции.
* Все остальное явялется true

*num* - приведение к числовому типу.

* Логические значения трактуются как true = 1, false = 0.
* null = 0.
* Пустые строки = 0. Не пустые строки парсятся как числовое значение.

Общая форма команды **{$num:аргумент:числовой_формат}**
*числовой_формат* является не обязательным аргументом и может принимать значения

* i - int
* l - long
* d - double
* f - float

*str* - приведение значения к строки. Аналогично вызову метода toString

*type* - выводит полное имя класса агрумента

#### Условия или команды ветвления

Все команды ветвления являются блочными. Но могут быть использованы как вложенные. Что позволяет их комбинировать.
Например:
```
{$or:{$eq:$a:$b}:{$eq:$c:$d}}
a == b || c == d
{$end}
```


*eq* - сравнивает два агрумента (Вызывет метод equals). второй агрумент явялется не обзательным. В этом случае он приводится к логическому значению.

*if* - синоним eq. Хорошей практикой будет использовать if c одни аргументом, а eq с двумя.

*or* - логическое "ИЛИ". Блок выполнится если любой из аргументов является true

*and* - логическое "И". Блок выполниется если все аргументы является true

*contains* - может быть использована для проверки наличия элемента в коллекции или ключа в мапе. Формат команды **{$contains:коллекция:элемент}**

*gt* - аналог >. Принимает два аргумента

*gte* - аналог >=. Принимает два аргумента

*lt* - аналог <. Принимает два аргумента

*lte* - аналог <=. Принимает два аргумента

*bt* - Принимает три аргумента. Блок выолниется если значение первого аргумент находится между вторым и третим. Или равно одному из них.

*not* - логическое отрицание

#### else

Команда *else* позволяет разбивать блок условия на несколько блоков. Команда может принимать один агрумент, который приводится к логическому значению.
Если значие агрумента true то блок вылолнится. Можно использовать несколько блоков *else* в пределах одного блока условий. 
Блок *else* выполнится только если предыдущие блоки не были выполнены.

#### Циклы

Все циклы тоже являются блочными командами. На каждую итерацию в блоке цикла создается несколько пременных:

* index - индекс элемента
* value - значение элемента
* key - ключ элемента при итерации по мапе
* total - количество итераций которые выполнит цилк, иними словари размер коллекции
* last - флаг являеется итерация последней или нет

*each* - стандарный цикл. Принемает один аргумент коллекци или мапу.

*sort* - упарядоченый цикл. сортирует элеменеты по значени.

*sortByKey* - аналогично sort. Только значения сортируются по ключу. Полезен при использовании с мапами.

*sbk* - синоним *sortByKey*

*range* - генерирует диапазон чисел. Команда имеет несколько форматов в зависимоте от количества агументов

* **{$range:количесво_итераций}**
* **{$range:начальное_значение:количесво_итераций}**
* **{$range:начальное_значение:количесво_итераций:размер_шага}**

#### break и next

Внутри блока цикла можно использовать команды *break* чтобы прервать выполнения цикла, или *next* чтобы перейди к следующей итерации цикла

#### Математика

*calc* - команда принемает один аргумент который должен быть математическим выражением. Например **{$calc: 2 + 2 * 2}** вернет 6

*math* - позволяет выполнить некоторые математические функции. Формат команды **{$math:имя_функции:мат_выражение}**.Доступные функции: *floor, ceil, round, abs, sqrt, exp, log, log10, cbrt*

*rand* - возвращяет случайное число

#### Остальные команды

*out* - печатает аргумент

*numFormat* - печатает число в заданом формате **{$numFormat:число:формат}**
 Причем формат не является обязательным, если его не передовать будет использован формат вывода заданный в настройках парсера
 
*upperCase* - переводит строку в верхний регист

*lowerCase* - переводит строку в нижний регист

*size* - возвраящет размер коллекции или длину строки

### Аргументы

Можно выделить слудующие типы агрументов:

* Строковой. Последовательность символов в одинарных кавычках **{$out:'Пример'}**
* Числой. Формат чисел зависит от inputNumberFormat настроек парсера. Парсер считает чиловым аргументом любую последовательнось символов начинющуюся с цифры
* Логический. **true** или **false**
* Переменные. Последовательность символов начинающаяся с символа '$'. Пример **{$out:$someVar}**
* Вложенное выражение. Например **{$out:{$lowerCase:'HELLO!'}}**, где **{$lowerCase:'HELLO!'}** является вложеным
* Доступ к данным. Любая последовательность символов, которая не является не одним из предыдуших типов агрументов. Например **{$out:some.data.access}**

Стоит заметить что некоторые команды могут трактовать агрументы по совему.
К примеру *calc* и *math* принимают мат. выражения. При этом в внутри этих выражения могут содержатся типы агрументов из списка выше.
Например **{$calc:(1 + {$num:'1'}) * $someAnotherNum}**

#### Доступ к элементам коллекций и мап

Если результатом аргумента являеется коллекци или мапа, то получить конретный элемент по индексу или имени можно при помощи символа '#'
Например **$someArr#0** верент 0 элемент из массива someArr. Более того выражения с права от '#' тоже является агрументом, 
т.е можно использовать **$someArr#$someIndex**. Также можно использовать несколько '#' для работы с вложеными коллекциями и мапами
Например **$someArr#$someIndex#$someSubArrayIndex**
 
 
## Cинтаксис для entities-logic

### Доступ к параметрам

Доступ к параметрам осуществляется через агрументы парсера(Доступ к данным).
Общая форма выглядит так **{$our:путь_к_полю.имя парметра}** путь с к полю явялется не обязательным,
его можно использовать для доступа к параметрам вложенных полей, имена полей в пути разделятся точкой.

Примеры:

* **{$out:label}** - выводит значения парметра label
* **{$out:first_value.label}** - выводит значения парметра label поля first_value

####Конвенция имен параметров и приведение значений

Для имен параметров существует аналог [Венгерской нотации](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BD%D0%B3%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F)
Существет набор правил которые в зависимости от префикса имени парметра производят приведение значени парметра.

Префиксы:

* n_ - значением параметра является число. 
* b_ - логическое значение парметра(true или false)
* l_ - значением параметра является мнемоника локализации. Результатом будет переведенная фраза.
* d_ - значение пареметра мнемоника из локализации. Результатом будет мапа содержащая пары ключ-значение словаря.

Иногда такой способ представления пареметров не нужен и требуется именно строковое значение параметра в этом случае
можно обращятся к парметрам в такой форме **{$our:@params.путь_к_полю.имя парметра}**

### Доступ к значению и PostfixValue

К значению примитива или PostfixValue связанным с данным полем можно обрашяст также как и к переменным.
Например **{$out:value}**, **{$each:query}**, **{$each:aggs}**

### Команды

*proto* - Позволяет вставить в текущий шаблон, шаблон прототипа модели.

*tmpl* - Позволяет вставить в текущий шаблон, шаблон поля модели. Единственным агрументом команды является путь к полю **{$tmpl:some_field}**

*phrase* - Переводит мнемонику из локализации в фразу. Комнда принемает единственный **строковой** аргумент. Пример: **{$phrase:'мнемонка.из.локализации'}**, **{$phrase:some_field.some_sub_field}**, **{$phrase:$label}**

*name* - Генерирует имя поля для форм. **{$name:some_field.some_sub_field}** вернет **some_field.some_sub_field**

*sortoreach* - В зависимости от парметра *sort* модели. Произойдет упорядоченая или не упорядоченая итерация по аргументу.
 
*dictKeyVal* - возвращяет значение ключа словаря. Форма команды **{$dictKeyVal:мнемоника_словаря:мнемоника_ключа}**.
Т.к для словарей существует конвенция имен с приведение типа, то логичным способом достать значение ключа было бы **{$out:d_dictionary#'some_key'}** однако это не самый быстрый способ т.к. приведет к конвертации всех ключей.
 Доспут к словараю посредсвам приведения значения удобен для итерации по словарю **{$each:d_dictionary}** однако совсем не подходит для получения конкретного значения ключа.
 Для этого лучше использовать **{$dictKeyVal:@params.d_dictionary:'some_key'}**
 
 
#### Сокращения 

Для многих команд вводится ряд сокращений:

* *o* - *out*
* *v* - *var*
* *s* - *sort*
* *e* - *each*
* *soe* - *sortoreach*
* *sbk* - *sortByKey*
* *t* - *tmpl*
* *r* - *range*
* *p* - *proto*
* *eif* - *else*
* *n* - *name*


## Интерфейсы расширения

Парсер содержит ряд точек позволяющих расширить и дополнить его функционал.

### Переменные

Можно задать переменные вызовом метода `CoreParser.setVariable(String name, Object value)`. При этом value может быть реализацией инерфейса ContextVariable
```
public interface ContextVariable {
    Object getValue(Context context);
}
```
В этом случа результатом переменой является вызов метода getValue

### Команды

Есть возможность добавить свою команду методом `TokensAnalyzer.addExpression(String name, Class<? extends Expression> exp)` или удалить методом `TokensAnalyzer.removeExpression(String name)`
```
parser.getTokenAnalyzer().addExpression("makeAllFine", new MakeAllFineExpression())
```
Все ваши команды должны наследоваться от класса `Expression` или его наследников `SingleArgumentExpression`, `NoArgumentsExpression`, `ConditionExpression`, `CycleExpression`

### DataAccessor

Это базовый интерфейс предоставлющий доступ к внешним данным.

```
public interface DataAccessor {
    Object getValue(Object...keys) throws Exception;
}
```

Метод `getValue` принимает аргумент типа 'Доступ к данным' разделеный по точкам.
Иными словами аргумент вида **some_field.some_params** певраящется в массив `new Object[]{"some_field", "some_params"}`  и передается в этот метод

```
CoreParser.parseTemplate(String template, DataAccessor dataAccessor) 
```


Есть примитвная реализаци этого интефейса `DataBinding` представляющая собой обвертку над HashMap.
entities-logic содержит реализацию этого интерфейса `EntitiesDataBinder`, создание которого зачастую скрыто от пользователя.

### EntitiesDataBinder и PostfixValue

Сам `EntitiesDataBinder` содержит поддрежку еще одного интерфейса `PostfixValue` который позволяет обращаться к каким либо данным на подобии обращения к параметру.

```
public interface PostfixValue {
    String getAccessKey();
    Object getValue(String fieldName);
}

```

### DictionariesSource, LocalizationSource, TemplatesSource

`DictionariesSource`, `LocalizationSource`, `TemplatesSource` ряд интефейсов entities-logic парсера. Реализации этих инетерфейсов должны соотвественно предоставля доступ парсеру к словарям, локализации и шаблонам моделей

### Интерфейс Debuggable

```
public interface Debuggable {
    void printDebug(StringBuilder sb);
}
```

`DataAccessor`, `ContextVariable`, `Expression` могут применятся с этим инетерфейсом для предостовления своей отладочной информации в случае возниконовения ошибки.